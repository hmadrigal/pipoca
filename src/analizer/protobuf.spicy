module PROTOBUF;

import spicy;

type WireType = enum {
    # int32, int64, uint32, uint64, sint32, sint64, bool, enum
    VARINT = 0 ,
	# fixed64, sfixed64, double
    I64 = 1,
    # string, bytes, embedded messages, packed repeated fields
    LEN = 2,
    # group start (deprecated)
    SGROUP = 3,
    # group end (deprecated)
    EGROUP = 4,
    # fixed32, sfixed32, float
    I32 = 5
};

# See Protobuf encoding at https://protobuf.dev/programming-guides/encoding/

# TODO: Reconsider whether to use VarintSegment or deal with bytes instead
# Segment is 8-bit. 0..6 are a part of the value, 7 is a flag to indicate last segment.
type VarintSegment  = unit {
    f: bitfield(8) {
        data: 0..6 &convert=cast<uint8>($$);
        is_last: 7 &convert=cast<bool>($$); 
    } ;
};

# https://protobuf.dev/programming-guides/encoding/#varints
type Varint = unit {
    # &max-size=10 
    segments: VarintSegment[] &until-including=( ! $$.f.is_last ) { 
        # self.value is computed based on segments
        local i : uint8  = 0;
        local c : uint64 = 0; 
        local n : uint64 = 0;
        local o : uint8;
        while (i < |$$| ) {
            c = $$[i].f.data ;
            o = i * 7;
            n = n | (c << o);
            # print "c=0x%x n=0x%x o=%d" % (c,n,o);

            i++;
        }
        # print n;
        self.value = n;
    }

    var value: uint64 &optional;

    #on %done { print "Done: %s" %  self ; }
} &convert=self.value;

# https://protobuf.dev/programming-guides/encoding/#structure
# tag is a varint encoded value where 3 lower bits are wire_type and remaining bits are field number
type Tag = unit {
    varint: Varint {  
        self.field_number = $$ >> 3;
        self.wire_type = WireType(($$ << 61) >> 61);
     }

    var field_number: uint64 &optional;
    var wire_type: WireType &optional;

    #on %done { print "Done: %s" %  self ; }
};

type I64 = unit {
    # encoded as 8-byte little-endian;
    # memcpy of the equivalent C types (u?int32_t, float)
    data: bytes &size=8;
};

type Len = unit {
    # size encoded as int32 varint
    size: Varint;
    # (message | string | bytes | packed)
    data: bytes &size=self.size {
        local s: string;
        #s = cast<string>($$);
        #print cast<Message>($$);
    }
    #text: string &parse-from=self.data;
    #var message: Message &optional;
};

#type SGroup = unit {
#
#};

#type EGroup = unit {
#
#};

type I32 = unit {
    # encoded as 4-byte little-endian;
    # memcpy of the equivalent C types (u?int32_t, float)
    data: bytes &size=4;
};

# https://protobuf.dev/programming-guides/encoding/#structure
# Record is computed by a tag and a value. Value length depends on the tag.
type Record = unit {
    tag: Tag;

    switch ( self.tag.wire_type ) { 
        WireType::VARINT -> varint: Varint;
        WireType::I64    -> i64: I64 &optional ;
        WireType::LEN    -> len: Len &optional ;
        #WireType::SGROUP -> sgroup: SGroup &optional ;
        #WireType::EGROUP -> egroup: EGroup &optional ;
        WireType::I32    -> i32: I32 &optional ;
    };
};

# https://protobuf.dev/programming-guides/encoding/#structure
# Message is made of a sequence of Records
public type Message = unit {
    records : Record[] ;

    on %done { print "Done: %s" %  self ; }
};